public class binaryTree{
    public static void main(String[] args){
        // 모든 원소는 서로다른 유일한 키를 갖느나.
        // 왼쪽 서브트리에 있는 원소의 키는 그 루트의 키보다 작다.
        // 오른쪽 서브 트리에 있는 원소의 키는 그 루트의 키보다 크다.
        // 왼쪽 서브 트리와 오른쪽 서브 트리도 이진탐색 트리다.
        System.out.println("hello");
        // if(x == 루트) 원하는 원소를 찾았으므로 탐색 성공
        // else if(루트 > x) 루트의 왼쪽 서브트리에 대해서 탐색 연산 수행
        // else if(루트 < x) 루트의 오른쪽 서브트리에 대해서 탐색 연산 수행

        // 이진트리 탐색 트리 삽입연산
        // 원소를 삽입 하려면 먼저 이진 탐색 트리에 같은 원소가 있는지를 확인하기 위해 탐색을 해야한다.
        // if(탐색성공) 이미 같은 원소가 트리내에 있는 것이므로 삽입 연산을 수행하지 않는다.
        // else if(탐색 실패) 크기를 비교하여 찾아간 노드으 ㅣ위치에 같은 원소가 없는 것이므로 그 자리에 원소를 삽입

        // 이진 탐색 트리 삭제 연산
        // 원소를 삭제하는 경우 자식 노드의 수에 따라 세가지 경우가 있다.
        // 노드를 삭제한 후에도 여전히 이진 탐색트리를 ㅇ지해야 하기 때문에 각각의 경우에 따라 후속처리가 필요하다.

        // 삭제할 노드가 단말 노드인 경우(노드를 삭제하고 부모노드의 링크 필드를 null로 설정하는 작업으로 간단 처리)
        // 삭제할 노드가 한개의 자식노드를 가진 경우(차수가 1인 경우, 노드를 삭제하고 나면 자식노드가 트리에서 떨어저 고아가 되므로, 남겨진 자식노드를 삭제한 부모 노드의 자리로 올려준다.)
        // 삭제할 노드가 두개의 자식 노드를 가진 경우(차수가2인 경우, 노드를 삭제하고 나면 부모노드의 자리를 자식 노드에게 물려줄때 왼쪽 에서 가장 큰 자손 노드 또는 오른쪽 중에서  가장 작은 자손 노드가 올라옴
                                                            //   이후 후계자로 자식 노드가 이동해올라옴

        
    }
}